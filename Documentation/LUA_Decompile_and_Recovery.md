# Декомпиляция LUA-скриптов Warface и их восстановление до рабочего состояния

Lua — скриптовый язык программирования. Интерпретатор языка является свободно распространяемым, с открытым исходным кодом на языке программирования C. В Warface используется версия Lua 5.1 (запомните на будущее, это нам ещё пригодится), и используется он для написания скриптов сущностей и большинства логики работы некоторых процессов игры.

** ВНИМАНИЕ! Данная статья написана для тех, кто более-менее понимает в программировании, а также может понять синтаксис языка LUA. Если вы ничего не понимаете, то соваться сюда вам не стоит! **

## Зачем декомпилировать LUA-скрипты?

В игре все LUA-скрипты зашифрованы (закомпилированы при помощи LuaCompiler внутри редактора CryEngine), так как они содержат информацию, которую желательно в явном виде не предоставлять. Но нам, любителям движка и кастомного контента, это как раз мешает, так как в некоторых случаях зашифрованные скрипты (нам интересны именно сущности) не работают, и чтобы они нормально функционировали, их необходимо расшифровать и восстановить.
* Для этого и создана данная статья, в ней вы узнаете: где декомпилировать LUA-скрипты Warface, большинство тонкостей этого процесса и как восстанавливать скрипты до рабочего состояния.

## Декомпиляция

Декомпилировать LUA-скрипты из Warface можно двумя способами:
1. Пакет JAR [«unluac»](https://sourceforge.net/projects/unluac/). Unluac — это декомпилятор для Lua 5.0–5.4. Он работает с фрагментами Lua, скомпилированными стандартным компилятором Lua. Он требует, чтобы из фрагмента не была удалена информация об отладке. Данный способ очень затратный по времени, так как данный пакет восстанавливает структуру кода только в общем виде, на то, чтобы полностью собрать структурированный код после декомпиляции, вам потребуется хорошее знание синтаксиса языка и большое количество времени и нервов. Данный пакет необходимо использовать с батником:
```bash
java -jar unluac.jar *.lua > decompile.lua
```
2. luac-parser (сайт luadec.metaworm.site). luac-parser — парсер байт-кода Lua, в настоящее время поддерживающий Lua 5.1–5.4, luajit и luau. В данном способе сайт очень хорошо восстанавливает структуру кода, поэтому вам потребуется меньше времени на полное восстановление кода. Но здесь нужно быть осторожным, так как при декомпиляции код содержит много ошибок, которые вам нужно будет исправить.

## Восстановление кода (на основе декомпиляции сайта luadec.metaworm.site)

После того как сайт декомпилировал код, вам необходимо его скачать или скопировать в отдельный LUA-файл, после чего вы можете начать с ним работать. Вот основные моменты, которые вам необходимо выполнить для его корректной работы:
* Удалить все комментарии, так как они не несут практической пользы ни для вас, ни для движка;
* Удалить все операторы «goto» с их ответвлением «else» (оператор «goto» был добавлен в версии Lua 5.2.0-beta-rc1, а затем усовершенствован в версии 5.2.0-beta-rc2. В версии 5.1, которую использует CryEngine и Warface, такого оператора нет), они выглядят примерно так:
```lua
else
    goto label_11
```
* Также необходимо удалить все метки. Метки — это идентификаторы, которые представляют точки в программе, к которым нужно выполнить переход. Метки обозначаются с помощью двоеточия (::) и должны быть уникальными в рамках одной функции. Команда goto позволяет перейти к определённой метке или меткам в программе. В коде они выглядят примерно так:
```lua
-- Ваш код
:label_11:
-- Ваш код
```
* Далее, в каждой функции есть первый передаваемый аргумент, который обычно начинается как «r0_», также он может использоваться внутри самой функции, но с точки зрения синтаксиса и оптимизации это неправильно, поэтому данные «нулевые» аргументы необходимо заменить на «self» (воспользуйтесь функцией «Заменить» в текстовом редакторе), а из передаваемых аргументов «self» необходимо удалить (исключением будет являться локальная функция). Пример:
Было:
```lua
function Soldier_x:SetAnimationVariation(r0_2, r1_2, r2_2)
	if CryAction.IsClient() then
		r0_2.actor:SetAnimationVariationInput(r1_2, r2_2)
	else
		r0_2.allClients:ClAnimationVariation(r1_2, r2_2)
	end
end
```
Стало:
```lua
function Soldier_x:SetAnimationVariation(r1_2, r2_2) -- self был удалён из передаваемых аргументов
	if CryAction.IsClient() then
		self.actor:SetAnimationVariationInput(r1_2, r2_2) -- r0_2 заменён на self
	else
		self.allClients:ClAnimationVariation(r1_2, r2_2) -- r0_2 заменён на self
	end
end
```
НО (так выглядит локальная функция, в данном случае «self» в передаваемых аргументах сохраняется):
```lua
OnInit = function(self)
	self:CliSrv_OnInit()
	self:OnMove()
	self:LoadSounds()
end
```
* В каждой строке определения функции необходимо поставить двоеточие перед последним методом. То есть, к примеру, после декомпилирования у вас будет функция:
```lua
function Soldier.Server.OnUpdate(r0_1, r1_0)
	-- Код функции
end
```
В таком виде она работать не будет, чтобы она стала правильной и работала корректно, вам необходимо заменить точку на двоеточие перед последним методом «OnUpdate»:
```lua
function Soldier.Server:OnUpdate(r1_0)
	-- Код функции
end
```
* Ну и последнее, что вам необходимо, это подправить синтаксис:
	* Замените пробелы на табуляцию;
	* Таблицы, которые заполняются постепенно, объедините сразу;
	* Если вы знаете, как сделать код меньше и проще, то сделайте это, так как оптимизация никогда не повредит;

В нашем канале по [этой ссылке](https://t.me/c/2000850874/47) вы можете посмотреть видео-пример восстановления скрипта \[Game\Scripts\Entities\AI\Soldier_x.lua\], также там будут прикреплены файлы, чтобы вы смогли сами посмотреть, как изменился скрипт.
